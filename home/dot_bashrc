#!/usr/bin/env bash

# `bashrc` is the individual per-interactive-shell startup file.

# @url https://gist.github.com/zachbrowne/8bc414c9f30192067831fafebd14255c
# @url https://gitlab.com/dwt1/dotfiles/-/raw/master/.bashrc
# @url https://wiki.archlinux.org/title/Bash
# This configuration file is heavily inspired by these sources.

# @url https://unix.stackexchange.com/questions/104755/how-can-i-create-a-local-function-in-my-bashrc
# Delete functions that should not exceed this bashrc's scope.
_cleanup() {
  unset -f _cleanup
  unset -f _is_running_interactively
  unset -f _main
  unset -f _set_bash_history
  unset -f _set_shopt
  unset -f _source_programs
}

# Returns true if the current shell is running interactively, and false
# otherwise.
_is_running_interactively() {
  [[ $- != *i* ]]
  return $?
}

# Set aliases.
_set_aliases() {
  # Change output format.
  alias df="df -h"
  alias free="free -h"

  # Colorise output.
  alias grep="grep --color=auto"
  alias ls="ls --color=auto"
  alias tree="tree -C"

  # Confirm before overwriting something.
  alias cp="cp --interactive"
  alias mv="mv --interactive"

  # Make parent directories as needed, with their file modes unaffected by any
  # `--mode` option.
  alias mkdir="mkdir -p"
}

# Set bash history related variables.
_set_bash_history() {
  # Bash history does not contain duplicate lines or lines beginning with a
  # space.
  export HISTCONTROL=erasedups:ignoredups:ignorespace

  # Expand the bash history size.
  export HISTFILESIZE=10000
  export HISTSIZE=500
}

# Set and unset shell options.
_set_shopt() {
  # If set, a command name that is a directory name is executed as if it were
  # the cd command's argument. This option is only used by interactive shells.
  shopt -s autocd

  # If set, minor errors in the spelling of a directory component in a cd
  # command are corrected. The errors checked for are transposed characters, a
  # missing character, and one character too many. If a correction is found,
  # the corrected file name is printed, and the command proceeds. This option
  # is only used by interactive shells.
  shopt -s cdspell

  # If set, bash lists the status of any stopped and running jobs before
  # exiting an interactive shell. If any jobs are running, this causes the exit
  # to be deferred until a second exit is attempted without an intervening
  # command. The shell always postpones exiting if any jobs are stopped.
  shopt -s checkjobs

  # When resizing a terminal emulator, Bash may not receive the resize signal.
  # This will cause typed text to not wrap correctly and overlap the prompt.
  # The checkwinsize shell option checks the window size after each command
  # and, if necessary, updates the values of LINES and COLUMNS.
  shopt -s checkwinsize

  # If set, bash attempts to save all lines of a multiple-line command in the
  # same history entry.
  shopt -s cmdhist

  # If set, the history list is appended to the file named by the HISTFILE
  # variable's value when the shell exits, rather than overwriting the file.
  shopt -s histappend

  # If set, aliases are expanded as described in bash aliases. This option is
  # enabled by default for interactive shells.
  shopt -s expand_aliases
}

# Source external programs to enrich bash's capabilities.
_source_programs() {
  declare -r bash_completion="/usr/share/bash-completion/bash_completion"
  declare -r command_not_found="/usr/share/doc/pkgfile/command-not-found.bash"

  # By default, Bash only tab-completes commands, filenames, and variables. The
  # package `bash-completion` extends this by adding more specialized tab
  # completions for common commands and their options, which can be enabled by
  # sourcing `/usr/share/bash-completion/bash_completion`.
  [[ -r "$bash_completion" ]] && source "$bash_completion"

  # `pkgfile` includes a "command not found" hook that will automatically
  # search the official repositories, when entering an unrecognized command.
  # You need to source the hook to enable it.
  [[ -r "$command_not_found" ]] && source "$command_not_found"
}

# Change the shell working directory to the provided argument and list its
# contents. Only one argument is accepted.
cl() {
  cd -- "$@" && ls
}

# Make directories and change the shell working directory to the first
# argument specified.
mkcd () {
  mkdir -p -- "$@" && cd -- "$1" || return
}

_main() {
  _is_running_interactively && return
  _set_bash_history
  _set_shopt
  _source_programs
  _set_aliases
  _cleanup
}

_main
