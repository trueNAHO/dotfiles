#!/usr/bin/env bash

# `bashrc` is the individual per-interactive-shell startup file.

# @url https://unix.stackexchange.com/questions/104755/how-can-i-create-a-local-function-in-my-bashrc
# Delete functions that should not exceed this bashrc's scope.
_cleanup() {
  unset -f _cleanup
  unset -f _extend_path
  unset -f _is_running_interactively
  unset -f _main
  unset -f _set_aliases
  unset -f _set_bash_history
  unset -f _set_configs
  unset -f _set_shopt
  unset -f _set_system_defaults
  unset -f _source_programs
}

# Potentially extend the `PATH` variable.
_extend_path() {
  declare -r -a paths=(
    "$HOME/.bin"         
    "$HOME/.local/bin"
    "$HOME/p/applications"
  )

  for path in "${paths[@]}"; do
    [[ -d "$path" ]] && PATH="$path:$PATH"
  done 
}

# Returns true if the current shell is running interactively, and false
# otherwise.
_is_running_interactively() {
  [[ $- != *i* ]]
}

# Set aliases.
_set_aliases() {
  # Colorise output.
  alias grep="grep --color=auto"
  alias ls="ls --color=auto"
  alias tree="tree -C"

  # Confirm before overwriting something.
  alias cp="cp --interactive"
  alias mv="mv --interactive"

  # Make parent directories as needed, with their file modes unaffected by any
  # `--mode` option.
  alias mkdir="mkdir -p"
}

# Set bash history related variables.
_set_bash_history() {
  # Bash history does not contain duplicate lines or lines beginning with a
  # space.
  export HISTCONTROL=erasedups:ignoredups:ignorespace

  # Expand the bash history size.
  export HISTFILESIZE=10000
  export HISTSIZE=500
}

# Set configurations for various tools.
_set_configs() {
  # Causes searches to ignore case; that is, uppercase and lowercase are
  # considered identical. This option is ignored if any uppercase letters
  # appear in the search pattern; in other words, if a pattern contains
  # uppercase letters, then that search does not ignore case.
  export LESS="-Ri"

  # Set `bat` as manpager.
  export MANPAGER="sh -c 'col -bx | bat -l man -p'"
}

# Set and unset shell options.
_set_shopt() {
  # If set, a command name that is a directory name is executed as if it were
  # the cd command's argument. This option is only used by interactive shells.
  shopt -s autocd

  # If set, minor errors in the spelling of a directory component in a cd
  # command are corrected. The errors checked for are transposed characters, a
  # missing character, and one character too many. If a correction is found,
  # the corrected file name is printed, and the command proceeds. This option
  # is only used by interactive shells.
  shopt -s cdspell
  
  # If set, bash lists the status of any stopped and running jobs before
  # exiting an interactive shell. If any jobs are running, this causes the exit
  # to be deferred until a second exit is attempted without an intervening
  # command. The shell always postpones exiting if any jobs are stopped.
  shopt -s checkjobs

  # When resizing a terminal emulator, Bash may not receive the resize signal.
  # This will cause typed text to not wrap correctly and overlap the prompt.
  # The checkwinsize shell option checks the window size after each command
  # and, if necessary, updates the values of LINES and COLUMNS.
  shopt -s checkwinsize

  # If set, bash attempts to save all lines of a multiple-line command in the
  # same history entry.
  shopt -s cmdhist

  # If set, the history list is appended to the file named by the HISTFILE
  # variable's value when the shell exits, rather than overwriting the file.
  shopt -s histappend

  # If set, aliases are expanded as described in bash aliases. This option is
  # enabled by default for interactive shells.
  shopt -s expand_aliases
}

# Set system defaults.
_set_system_defaults() {
  # Set default terminal.
  export TERM="alacritty"

  # Set default text editor.
  export EDITOR="nvim"
  export VISUAL="nvim"
}

# Source external programs to enrich bash's capabilities.
_source_programs() {
  declare -r bash_completion="/usr/share/bash-completion/bash_completion"
  declare -r command_not_found="/usr/share/doc/pkgfile/command-not-found.bash"

  # By default, Bash only tab-completes commands, filenames, and variables. The
  # package `bash-completion` extends this by adding more specialized tab
  # completions for common commands and their options, which can be enabled by
  # sourcing `/usr/share/bash-completion/bash_completion`.
  [[ -r "$bash_completion" ]] && source "$bash_completion"
  
  # `pkgfile` includes a "command not found" hook that will automatically
  # search the official repositories, when entering an unrecognized command.
  # You need to source the hook to enable it.
  [[ -r "$command_not_found" ]] && source "$command_not_found"
}

# Make directories and change the shell working directory to the first
# directory specified.
mkcd () {
  mkdir -p -- "$@" && cd -- "$1" || exit
}

_main() {
  _set_system_defaults
  _is_running_interactively && return
  _set_bash_history
  _extend_path
  _set_shopt
  _set_configs
  _set_aliases
  _source_programs
}

_main
_cleanup
